## 1. railsルータの目的
- httpリクエストとコントローラのアクションの対応づけを行う
- ルーターに構成されたリソースに基づいてpathとヘルパーメソッド（パスヘルパー）を作ってくれる
  - APIモードだとテストとかでパスヘルパーを使っている
- 定義
  - get "/users/:id", to: "users#show", as: "user"
	- ルーティングの指定はスネークケースを使う
- オプション
  - to: コントローラ名#アクション名
  - as: ヘルパーメソッドを作る時のカスタム名を指定する
	- controller: コントローラを指定
	- action: アクション名を指定
- DSLで設定、rubyのファイルだから条件とかループとか利用できる
- user_url -> 絶対パス, user_path -> 相対パス

## 2. リソースベースのルーティング
- リソースルーティング
  - `resources`と宣言するだけで、7つのアクションのルーティングが生成される
  - 特定のHTTPメソッドのリクエストを特定の一つのコントローラ内のアクションに紐付ける
	- 4つのurlとhttpメソッドを組み合わせで、7つのアクションに割り当てている
	  - railsはroute.rbを上から見ていくので、具体なルートを上に、抽象的なルートを下にしないとうまくマッチできない
- パスヘルパーも作ってくれる
  - `resources :photos`
		- `photos_path` -> /photos
		- `new_photo_path` -> /photos/new
		- `edit_photo_path(:id)` -> /photos/:id/edit
		- `photo_path(:id)` -> /photos/:id
- 複数形、単数系
  - resources :books
	- resource :geocoder
	  - ユーザーが一つのリソースしか持たない場合もある
	  - indexアクションが作られない、それ以外は同じ
- コントローラの名前空間とルーティング
  - namespace :admin do...end
	  - パス、コントローラの場所、パスヘルパーにadminがつく
	- scope: module: "admin" do...end
		- パスとパスヘルパーの名前は変わらない、コントローラの場所だけ変わる（module配下になる）
	- scope: "/admin"
	  - パスだけ変わる。コントローラの場所とパスヘルパーは変わらない
- ネストしたリソース
	- ルーティングをネストすることで、リソースの親子関係を表現できる
	  - パスが親のパスの後に自分のパスになる
		  - `magazines/:magazine_id/ads`
		- コントローラの場所は変わんない(controllerディレクトリの直下)
	- ネストは一階層までにしたほうが良い（見づらくなる）
  - shallow: trueをつけるとネストを浅くできる
		- 子リソースに設定 -> そのリソースのメンバーアクションはネストせず、コレクションアクションだけネストするようになる
		- 親リソースに設定 -> ネストした子リソースに一括で指定できる
		- shallowブロック -> そのブロック内のネストしたリソースを一括で指定できる（複数の親リソースに設定する手間を省ける）
- shallow_path, shallow_urlオプション
  - コレクションだけネストしつつ、パスの名前とか変えられる
  - shallow_path :params -> urlだけ指定したパラメーターをprefixにつける
	- shallow_url :params -> ヘルパーメソッドの名前だけ変える
- concernもあるよ
	- 同じルーティングを使いまわせる
		```ruby
		concern :commentable do
			resources comments
		end

		resources: messages, concerns: :commentable
		```
	- namespaceとかでも使える
	  ```ruby
		namespace :messages do
			concerns: :commentable
		end
		```
- オブジェクトからパスとURLを生成することができる
- resourceにさらにルーティングを追加する
  - collection -> 複数の要素に作用するルーティング（index, create, newとか）
	- member -> 単一の要素に作用するルーティング（show, edit, update, destroy）
		- 特定のIDが必要
	  ``` ruby
		resources :photos do
			member do
				get "preview"
			end
		end
		```
		- /photos/1/previewを認識する
	- newアクションとかも追加できる
		```ruby
		resources :comments do
			get "preview", on: :new
		end
		```
		- /comments/new/preview
		- 保存する前に確認したいときとかに使える（memberにするには:idが必要なので、保存後でないといけない）
	- アクションが複数追加されていたら、resourceが隠れていないかを注意する

## 3. リソースフルでないルーティング
- リソースフルでないルーティングも追加できるよ
  - `get "photos/(:id)", to: :phots#display`
	- ()パラメータがあってもなくても良い
- 動的セグメント
	- /:userで受けれる
- 静的セグメント
	- /user
- クエリパラメーター
  - /:userに？以降のやつが全部入る
- default
- asでカスタム名
- セグメント制限
	- idとか
  - subdomainとか
- matchとviaで制限
- 高度
  - クラス作って、それをconstraints: にわたす
	  - match?に対応すれば良い
	- *セグメント
	  - ワイルドカード
  - format: true, false
	- redirect
	  - 301だから注意、status: 302で変更できる
	- rackアプリケーションにルーティング
	  - match, viaの使い道
	  - mount, at:
	- root
		- namespaceでも使える
	- unicode文字列
	  - ルーティングで"こんにちは"が使える
	- direct
		- パスヘルパーを自分で作れる
	- resolve
		- railsがmodelから自動的に判断するルーティングをオーバーライドできる

